# magicant's .yashrc for yash 2.14 and later

# read system-wide settings
if [ -r /etc/yashrc ]; then
	. /etc/yashrc
elif [ -r /etc/yash.yashrc ]; then
	. /etc/yash.yashrc
fi

# set some options
set --braceexpand --extendedglob --noclobber --nounset
# below are only available when lineedit is enabled
set --notifyle --histspace --le-noconvmeta 2>/dev/null

# if the shell is executed in gnome-terminal, set $TERM accordingly
if [ /proc/$PPID/exe -ef /usr/bin/gnome-terminal ]; then
	for term in gnome-256color gnome-16color gnome; do
		if tput -T $term init >/dev/null 2>&1; then
			export TERM=$term
			break
		fi
	done
	unset term
fi

termcolor=$(tput colors 2>/dev/null)

# define aliases
if command -vb alias >/dev/null; then  # check if alias is enabled

	: ${PAGER:=more}

	alias cp='cp -i'  # IMPORTANT!
	alias mv='mv -i'
	alias rm='rm -i'

	alias -- -='cd -'
	alias f='fg'
	alias gr='grep'
	alias he='head'
	alias j='jobs'
	alias la='ls -a'
	alias le='$PAGER'
	alias ll='ls -l'
	alias lla='ll -a'
	alias r='fc -s'
	alias so='sort'
	alias ta='tail'
	alias tree='tree -C'
	alias ci='vcs_ci' log='vcs_log' st='vcs_st' up='vcs_up'
	alias -g G='|grep'
	alias -g H='|head'
	alias -g L='|$PAGER'
	alias -g N='>/dev/null 2>&1' N1='>/dev/null' N2='2>/dev/null'
	alias -g S='|sort'
	alias -g T='|tail'

	if [ "$termcolor" -ge 8 ] && ls --color=tty -d . >/dev/null 2>&1; then
		alias ls='ls --color=tty'
	fi

	if command -v nkf >/dev/null 2>&1; then
		case "${LC_ALL:-${LC_CTYPE:-${LANG:-}}}" in
			*utf8* |*utf-8* |*UTF8* |*UTF-8* )
				alias nkf='nkf -xw --no-best-fit-chars';;
			*eucjp*|*euc-jp*|*EUCJP*|*EUC-JP*)
				alias nkf='nkf -xe';;
		esac
	fi

	if command -v vim >/dev/null 2>&1; then
		alias vi='vim'
		alias vl='vimless'
		alias -g V='|vimless'
	fi

	if command -v gnome-open >/dev/null 2>&1; then
		alias go='gnome-open'
	fi

fi

# add key bindings to vi mode, some of which are from emacs mode.
if command -vb bindkey >/dev/null; then
	bindkey -v '\^A' beginning-of-line
	bindkey -v '\^B' backward-char
	bindkey -v '\^D' eof-or-delete
	bindkey -v '\#'  eof-or-delete
	bindkey -v '\^E' end-of-line
	bindkey -v '\^F' forward-char
	bindkey -v '\^K' forward-kill-line
	bindkey -v '\^U' backward-kill-line
	bindkey -v '\$'  backward-kill-line
	bindkey -v '\^W' backward-delete-viword
	bindkey -v '\^Y' put-left
fi

# define some variables
{ SHLVL=$((SHLVL+1)) || SHLVL=1; } 2>/dev/null
export SHLVL
HISTFILE=~/.yash_history HISTSIZE=1000 HISTRMDUP=100
MAILCHECK=60
FCEDIT=${EDITOR:-vi}
HOSTNAME=${HOSTNAME:-$(uname -n)}
: ${ECHO_STYLE:=RAW}
COMMAND_NOT_FOUND_HANDLER=()
PROMPT_COMMAND=()
YASH_AFTER_CD=()

# define prompt
if [ -n "${SSH_CONNECTION-}" ] && [ -z "${SSH_LOCAL-}" ]; then
	hc='\fyo.'             # yellow in remote host
else
	hc='\fgo.'             # green for local
fi
if [ "$(id -u)" -eq 0 ]; then
	uc='\fro.' gc='\fro.'  # red for root
else
	uc="$hc"   gc='\fo.'   # normal
fi
PS1=$uc'${LOGNAME}'$hc'@${HOSTNAME%%.*}\fo. ${${${PWD:/~/\~}##*/}:-$PWD} ${VCS_INFO:+\\fc.${VCS_INFO}\\fo. }${SHLVL:/1}\$\f. '
PS2=$gc'>\f. '
PS4='+ '
unset uc gc hc

# set window title
# we assume the terminal supports window title if $termcolor >= 8
if [ "$termcolor" -ge 8 ]; then
	_set_term_title()
	if [ -t 2 ]; then
		printf '\033]0;%s@%s:%s\a' "${LOGNAME}" "${HOSTNAME%%.*}" \
			"${${PWD:/$HOME/\~}/#$HOME\//\~\/}" >&2
	fi
	PROMPT_COMMAND=("$PROMPT_COMMAND" '_set_term_title')
	ssh() {
		if [ -t 2 ]; then printf '\033]0;ssh %s\a' "$*" >&2; fi
		command ssh "$@"
	}
fi

# tricks to show VCS info in the prompt
_update_vcs_info() {
	if [ -d .svn ]; then
		VCS_INFO=svn
		return
	fi
	VCS_INFO=$(
		while true; do
			if [ -d .hg ]; then
				printf 'hg:'
				exec hg branch 2>/dev/null
			elif [ -d .git ]; then
				printf 'git:'
				exec git branch >(grep '^\*' | cut -c 3-) 2>/dev/null
			fi
			if [ / -ef . ] || [ . -ef .. ]; then
				exit
			fi
			cd -P ..
		done
	)
	case "$VCS_INFO" in
		hg:default)        VCS_INFO='hg';;
		git: | git:master) VCS_INFO='git';;
	esac
}
PROMPT_COMMAND=("$PROMPT_COMMAND" '_update_vcs_info')

# autocd alternative for yash 2.13 and later
_autocd()
if [ -d "$1" ]; then 
	HANDLED=true
	cd "$@"
	break -i
fi
COMMAND_NOT_FOUND_HANDLER=("$COMMAND_NOT_FOUND_HANDLER" '_autocd "$@"')

# alternative to zsh's auto_pushd option
cd()
if [ $# -gt 0 ]; then
	pushd "$@"
else
	pushd ~
fi

# alternative to zsh's pushd_ignore_dups option
pushd() {
	command -b pushd "$@" && {
		# remove $PWD from $DIRSTACK
		typeset i=1
		while [ $? -eq 0 ] && [ $i -le ${DIRSTACK[#]} ]; do
			if [ x"$PWD" = x"${DIRSTACK[$i]}" ]; then
				array -d DIRSTACK $i
			else
				i=$((i+1))
			fi
		done
	}
}

# print file type for unexecutable files
_print_file_type()
if [ -e "$1" ] && ! [ -d "$1" ]; then
	file "$1"
fi
COMMAND_NOT_FOUND_HANDLER=("$COMMAND_NOT_FOUND_HANDLER" '_print_file_type "$@"')

# use more as pager in dumb terminal
if [ x"$TERM" = x"dumb" ]; then
	PAGER=more
fi

# define some auxiliary functions
args()
if [ $# -gt 0 ]; then
	printf '%s\n' "$@"
fi
mkdircd() {
	mkdir -p "$@" && cd "$1"
}
vcs_ci() {
	${${VCS_INFO:?Not in version-controlled directory}%%:*} commit "$@"
}
vcs_log() {
	${${VCS_INFO:?Not in version-controlled directory}%%:*} log "$@"
}
vcs_st() {
	${${VCS_INFO:?Not in version-controlled directory}%%:*} status "$@"
}
vcs_up() {
	${${VCS_INFO:?Not in version-controlled directory}%%:*} update "$@"
}

# read local settings
if [ -r ~/.yashrc_local ]; then
	. ~/.yashrc_local
fi

unset termcolor

# vim: ts=4 sw=4 ft=sh
